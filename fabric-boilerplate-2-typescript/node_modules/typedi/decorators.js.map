{"version":3,"sources":["decorators.ts"],"names":[],"mappings":";AAAA,0BAAwB,aAAa,CAAC,CAAA;AAEtC;;;;;GAKG;AACH,iBAAwB,IAAa;IACjC,MAAM,CAAC,UAAS,MAAgB;QAC5B,IAAM,MAAM,GAAU,OAAQ,CAAC,WAAW,CAAC,mBAAmB,EAAE,MAAM,CAAC,CAAC;QACxE,qBAAS,CAAC,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACpD,CAAC,CAAC;AACN,CAAC;AALe,eAAO,UAKtB,CAAA;AAOD,gBAAuB,UAA8C;IACjE,MAAM,CAAC,UAAS,MAAW,EAAE,GAAW,EAAE,KAAc;QAEpD,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC;YACZ,UAAU,GAAG,cAAM,OAAO,OAAQ,CAAC,WAAW,CAAC,aAAa,EAAE,MAAM,EAAE,GAAG,CAAC,EAAvD,CAAuD,CAAC;QAE/E,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC;YACtB,qBAAS,CAAC,oBAAoB,CAAC;gBAC3B,IAAI,EAAE,MAAM;gBACZ,KAAK,EAAE,KAAK;gBACZ,QAAQ,EAAE,cAAM,OAAA,qBAAS,CAAC,GAAG,CAAC,OAAO,UAAU,KAAK,QAAQ,GAAG,UAAU,GAAG,UAAU,EAAS,CAAC,EAAhF,CAAgF;aACnG,CAAC,CAAC;QACP,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,qBAAS,CAAC,uBAAuB,CAAC;gBAC9B,MAAM,EAAE,MAAM;gBACd,GAAG,EAAE,GAAG;gBACR,QAAQ,EAAE,cAAM,OAAA,qBAAS,CAAC,GAAG,CAAC,OAAO,UAAU,KAAK,QAAQ,GAAG,UAAU,GAAG,UAAU,EAAS,CAAC,EAAhF,CAAgF;aACnG,CAAC,CAAC;QACP,CAAC;IACL,CAAC,CAAC;AACN,CAAC;AApBe,cAAM,SAoBrB,CAAA;AAED;;;;;GAKG;AACH,iBAAwB,IAAY;IAChC,MAAM,CAAC,UAAS,MAAW,EAAE,GAAW,EAAE,KAAc;QAEpD,EAAE,CAAC,CAAC,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC;YACtB,qBAAS,CAAC,oBAAoB,CAAC;gBAC3B,IAAI,EAAE,MAAM;gBACZ,KAAK,EAAE,KAAK;gBACZ,QAAQ,EAAE,cAAM,OAAA,OAAO,CAAC,IAAI,CAAC,EAAb,CAAa;aAChC,CAAC,CAAC;QACP,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,qBAAS,CAAC,uBAAuB,CAAC;gBAC9B,MAAM,EAAE,MAAM;gBACd,GAAG,EAAE,GAAG;gBACR,QAAQ,EAAE,cAAM,OAAA,OAAO,CAAC,IAAI,CAAC,EAAb,CAAa;aAChC,CAAC,CAAC;QACP,CAAC;IACL,CAAC,CAAC;AACN,CAAC;AAjBe,eAAO,UAiBtB,CAAA","file":"decorators.js","sourcesContent":["import {Container} from \"./Container\";\n\n/**\n * Marks class as a service that can be injected using container.\n *\n * @param name Optional service name can be specified. If service name is specified then this service can only be\n *              retrieved by a service name. If no service name is specified then service can be retrieved by its type\n */\nexport function Service(name?: string) {\n    return function(target: Function) {\n        const params = (<any> Reflect).getMetadata(\"design:paramtypes\", target);\n        Container.registerService(name, target, params);\n    };\n}\n\n/**\n * Injects a service into class property or into constructor parameter.\n */\nexport function Inject(type?: (type?: any) => Function): Function;\nexport function Inject(serviceName?: string): Function;\nexport function Inject(typeOrName?: ((type?: any) => Function)|string): Function {\n    return function(target: any, key: string, index?: number) {\n\n        if (!typeOrName)\n            typeOrName = () => (<any> Reflect).getMetadata(\"design:type\", target, key);\n\n        if (index !== undefined) {\n            Container.registerParamHandler({\n                type: target,\n                index: index,\n                getValue: () => Container.get(typeof typeOrName === \"string\" ? typeOrName : typeOrName() as any)\n            });\n        } else {\n            Container.registerPropertyHandler({\n                target: target,\n                key: key,\n                getValue: () => Container.get(typeof typeOrName === \"string\" ? typeOrName : typeOrName() as any)\n            });\n        }\n    };\n}\n\n/**\n * Makes a \"require\" npm package with the given name and injects its value.\n * NOTE: experimental.\n *\n * @param name The name of the package to require\n */\nexport function Require(name: string) {\n    return function(target: any, key: string, index?: number) {\n\n        if (index !== undefined) {\n            Container.registerParamHandler({\n                type: target,\n                index: index,\n                getValue: () => require(name)\n            });\n        } else {\n            Container.registerPropertyHandler({\n                target: target,\n                key: key,\n                getValue: () => require(name)\n            });\n        }\n    };\n}\n"],"sourceRoot":""}